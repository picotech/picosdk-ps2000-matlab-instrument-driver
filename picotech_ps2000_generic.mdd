<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>picotech_ps2000_generic.mdd</DriverName>
   <DriverType>MATLAB generic</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Pico Technology Ltd.</InstrumentManufacturer>
   <InstrumentModel>PicoScope 2000 Series</InstrumentModel>
   <InstrumentVersion>1.1.22</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
%
% Copyright © 2013-2017 Pico Technology Ltd. All rights reserved.
% You may copy and distribute this file as long as it remains unmodified.
% SB

    fprintf('\nCopyright © 2013-2017 Pico Technology Ltd. All rights reserved.\n');
    fprintf('\n');
    fprintf('PicoScope 2000 Series MATLAB Instrument Driver\n');
    fprintf('\n');
    
    % Load libraries
    % ==============
    
    % Indentify architecture and obtain function handle for the correct
    % prototype file.
    
    archStr = computer('arch');
    
    ps2000MFile = str2func(strcat('ps2000MFile_', archStr));
    ps2000WrapMFile = str2func(strcat('ps2000WrapMFile_', archStr));

    % Only load library once 
    if (libisloaded('ps2000'))
       
        % Do nothing
        
    else
        
        if (ismac)
            
            [ps2000NotFound, ps2000Warnings] = loadlibrary('libps2000.dylib', ps2000MFile, 'alias', 'ps2000');
            
        elseif (isunix)
            
            [ps2000NotFound, ps2000Warnings] = loadlibrary('libps2000.so', ps2000MFile, 'alias', 'ps2000');
                
        elseif (ispc)
            
            [ps2000NotFound, ps2000Warnings] = loadlibrary('ps2000.dll', ps2000MFile);
            
        else
            
            % Do nothing
                
        end
        
    end

     % Only load library once 
    if (libisloaded('ps2000Wrap'))
       
        % Do nothing
        
    else
                                                  
        if (ismac)
            
            [ps2000NotFound, ps2000Warnings] = loadlibrary('libps2000wrap.dylib', ps2000WrapMFile, 'alias', 'ps2000Wrap');
            
        elseif (isunix)
            
            [ps2000NotFound, ps2000Warnings] = loadlibrary('libps2000Wrap.so', ps2000WrapMFile, 'alias', 'ps2000Wrap');
             
        elseif (ispc)
            
            [ps2000NotFound, ps2000Warnings] = loadlibrary('ps2000Wrap.dll', ps2000WrapMFile);
            
        else            
            
            % Do nothing
                
        end
        
    end
    
    % Load in enumeration and structure information
    % =============================================
    
    [~, obj.DriverData.structs, obj.DriverData.enums, ~] = ps2000MFile(); 

    % Define constant values used by this Instrument Driver
    % =====================================================
    
    % Constants from ps2000.h header file
    % ---------------------------------------
    
    % Timebases
    obj.DriverData.constants.PS2000_MAX_TIMEBASE = 19;

    obj.DriverData.constants.PS2105_MAX_TIMEBASE = 20;
    obj.DriverData.constants.PS2104_MAX_TIMEBASE = 19;

    obj.DriverData.constants.PS2200_MAX_TIMEBASE = 23;
    obj.DriverData.constants.PS2000_MAX_OVERSAMPLE = 256;

    % ETS Mode
    obj.DriverData.constants.PS2105_MAX_ETS_CYCLES =	250;
    obj.DriverData.constants.PS2105_MAX_ETS_INTERLEAVE =	50;

    obj.DriverData.constants.PS2104_MAX_ETS_CYCLES =	125;
    obj.DriverData.constants.PS2104_MAX_ETS_INTERLEAVE =	25;

    obj.DriverData.constants.PS2203_MAX_ETS_CYCLES =	250;
    obj.DriverData.constants.PS2203_MAX_ETS_INTERLEAVE = 50;

    obj.DriverData.constants.PS2204_MAX_ETS_CYCLES =	250;
    obj.DriverData.constants.PS2204_MAX_ETS_INTERLEAVE = 40;

    obj.DriverData.constants.PS2205_MAX_ETS_CYCLES =	250;
    obj.DriverData.constants.PS2205_MAX_ETS_INTERLEAVE = 40;

    obj.DriverData.constants.PS2000_MIN_ETS_CYCLES_INTERLEAVE_RATIO = 1;
    obj.DriverData.constants.PS2000_MAX_ETS_CYCLES_INTERLEAVE_RATIO = 10;

    % Function/Arbitrary Waveform Parameters
    obj.DriverData.constants.PS2000_MIN_SIGGEN_FREQ = single(0.0);
    obj.DriverData.constants.PS2000_MAX_SIGGEN_FREQ = single(100000.0);

    obj.DriverData.constants.PS2000_MIN_SIGGEN_OFFSET_MV = -2000;    % -2 Volts
    obj.DriverData.constants.PS2000_MAX_SIGGEN_OFFSET_MV = 2000;     % +2 Volts

    obj.DriverData.constants.PS2000_MIN_SIGGEN_PKTOPK_MV = 0;        % 0
    obj.DriverData.constants.PS2000_MAX_SIGGEN_PKTOPK_MV = 4000;     % +/- 2 Volts

    obj.DriverData.constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC = 0;

    obj.DriverData.constants.PS2000_AWG_DDS_FREQUENCY = 48e6; % DDS Frequency of 48MHz.

    % Although the PS2000 uses an 8-bit ADC, it is usually possible to
    % oversample (collect multiple readings at each time) by up to 256.
    % the results are therefore ALWAYS scaled up to 16-bits, even if
    % oversampling is not used.
    %
    % The maximum and minimum values returned are therefore as follows:

    obj.DriverData.constants.PS2000_MAX_VALUE = 32767;
    obj.DriverData.constants.PS2000_MIN_VALUE = -32767;
    obj.DriverData.constants.PS2000_LOST_DATA = -32768;

    obj.DriverData.constants.MAX_CHANNELS = 4;

    % PicoScope Models

    obj.DriverData.variants.MODEL_NONE    = 'NONE';
    obj.DriverData.variants.MODEL_PS2104  = '2104';
    obj.DriverData.variants.MODEL_PS2105  = '2105';
    obj.DriverData.variants.MODEL_PS2202  = '2202';
    obj.DriverData.variants.MODEL_PS2203  = '2203';
    obj.DriverData.variants.MODEL_PS2204  = '2204';
    obj.DriverData.variants.MODEL_PS2205  = '2205';
    obj.DriverData.variants.MODEL_PS2204A = '2204A';
    obj.DriverData.variants.MODEL_PS2205A = '2205A';
    
    
    
    
    </Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

    fprintf('Opening PicoScope 2000 Series device...\n\n');

    obj.DriverData.unitHandle = calllib('ps2000', 'ps2000_open_unit');

    % Verify handle returned
    if(obj.DriverData.unitHandle == -1)

        error('Oscilloscope failed to open.');

    elseif(obj.DriverData.unitHandle == 0)

        error('No oscilloscope found.');

    else

        % Display object information
        obj
      
        handle = obj.DriverData.unitHandle;

        % Obtain serial number
        infoline = blanks(40);

        [infoLength, unitSerial]  = calllib('ps2000', ...
                'ps2000_get_unit_info', handle, infoline, ... 
                length(infoline), PicoStatus.PICO_BATCH_AND_SERIAL);

        %set(obj, 'unitSerial', unitSerial);
        obj.DriverData.unitSerial = unitSerial;

        % Set variant and channel count information

        infoLineVariant = blanks(40);

        [infoLength, variant]  = calllib('ps2000', ...
                'ps2000_get_unit_info', handle, infoLineVariant, ... 
                length(infoline), PicoStatus.PICO_VARIANT_INFO);

        obj.InstrumentModel = variant;

        % Set device parameters
        invoke(obj, 'resetDevice');

        fprintf('\n');
        fprintf('Connected to PicoScope 2000 Series device:-\n\n');
        fprintf('     Instrument Model: %s\n', get(obj, 'InstrumentModel'));
        fprintf('  Batch/Serial Number: %s\n', unitSerial);
        fprintf('   Number of Channels: %d\n', get(obj, 'channelCount'));
        fprintf('        Buffer memory: %d samples\n', get(obj, 'bufferMemory'));
        fprintf('Maximum sampling rate: %d MS/s\n', (get(obj, 'maxSamplingRate')/1e6));

        % Output the signal generator type
        sigGenType = 'None';

        switch (obj.DriverData.sigGenType)

            case PicoConstants.SIG_GEN_FUNCT_GEN

                sigGenType = 'Function Generator';

            case PicoConstants.SIG_GEN_AWG

                sigGenType = 'Arbitrary Waveform Generator';

            otherwise

                % Already set to none

        end

        fprintf('Signal Generator Type: %s\n\n', sigGenType);

    end</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

    if(isfield(obj.DriverData,'unitHandle'))

        unitHandle = obj.DriverData.unitHandle;
    
        if (isempty(unitHandle)) 
            % If no unithandle, return without doing anything.
            return;
        end
    
        if(~libisloaded('ps2000') &amp;&amp; ~libisloaded('ps2000Wrap'))

            % If the drivers are no longer loaded, return without doing
            % anything.
            return;

        end

        % Disconnect Code:

        disconnectStatus = calllib('ps2000', 'ps2000_close_unit', unitHandle);

        if(disconnectStatus &gt; 0 )

            fprintf(['Connection to PicoScope %s with serial number %s ' ...
                'closed successfully.\n'], obj.InstrumentModel, obj.DriverData.unitSerial);
                
        elseif(unitHandle == 0)

            % No handle
            return;

        else

            error(['Connection to PicoScope %s with serial number %s ' ...
                'not closed. Status code %d\n'], ...
                obj.InstrumentModel, obj.DriverData.unitSerial, disconnectStatus);

        end    
    
        unloadlibrary('ps2000Wrap');
        unloadlibrary('ps2000');

        if (~libisloaded('ps2000') &amp;&amp; ~libisloaded('ps2000Wrap'))

            disp('Libraries unloaded successfully.');

        else

            disp('Libraries not unloaded successfully.');

        end
        
    else
        
        warning('Disconnect:NoDevicesFound', 'Disconnect: No devices found.');
        
    end
       

</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>bufferMemory</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If bufferMemory doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'bufferMemory') )
        obj.DriverData.awgBufferSize = 8192;
    else
        propertyValue = obj.DriverData.bufferMemory;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>8192</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Defines the size of the memory buffer on the device (in samples).</Description>
            </Property>
            <Property>
               <Name>channelCount</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If channelCount doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'channelCount') )
        obj.DriverData.channelCount = [ ];
    end

    propertyValue = obj.DriverData.channelCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of input channels on the device. (DO NOT EDIT)</Description>
            </Property>
            <Property>
               <Name>channelSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If channelSettings doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'channelSettings') )

        obj.DriverData.channelSettings = [ ];

        obj.DriverData.channelSettings.channelA.enabled = PicoConstants.TRUE;
        obj.DriverData.channelSettings.channelA.dc = PicoConstants.TRUE;
        obj.DriverData.channelSettings.channelA.range = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_5V');

        if(obj.DriverData.channelCount == PicoConstants.DUAL_SCOPE)

            obj.DriverData.channelSettings.channelB.enabled = PicoConstants.TRUE;
            obj.DriverData.channelSettings.channelB.dc = PicoConstants.TRUE;
            obj.DriverData.channelSettings.channelB.range = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_5V');

        end

    else

        propertyValue = obj.DriverData.channelSettings;

    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

if(isStruct(propertyValue))
    
    obj.DriverData.channelSettings = propertyValue;
    
else
    
    error('Cannot set channelSettings - not a structure').
    
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Object</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>A structure containing the channel settings.</Description>
            </Property>
            <Property>
               <Name>firstRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If firstRange doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'firstRange') )
        obj.DriverData.firstRange = [ ];
    else
        propertyValue = obj.DriverData.firstRange;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Lowest voltage range supported by the device (mV).</Description>
            </Property>
            <Property>
               <Name>hasAdvancedTrigger</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If hasAdvancedTrigger doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'hasAdvancedTrigger') )
        obj.DriverData.hasAdvancedTrigger = 0;
    else
        propertyValue = obj.DriverData.hasAdvancedTrigger;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Boolean</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Indicates if the PicoScope unit has Advanced Trigger functionality.</Description>
            </Property>
            <Property>
               <Name>hasEts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If hasEts doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'hasEts') )
        obj.DriverData.hasEts = 0;
    else
        propertyValue = obj.DriverData.hasEts;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Boolean</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Indicates if the device supports Equivalent Time Sampling (Ets).</Description>
            </Property>
            <Property>
               <Name>hasFastStreaming</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If hasFastStreaming doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'hasFastStreaming') )
        
        obj.DriverData.hasFastStreaming = 0;
        
    else
        
        propertyValue = obj.DriverData.hasFastStreaming;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Boolean</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Indicates if the device supports collection of data using Fast Streaming.</Description>
            </Property>
            <Property>
               <Name>lastRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If lastRange doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'lastRange') )
        obj.DriverData.lastRange = [ ];
    else
        propertyValue = obj.DriverData.lastRange;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Highest voltage range supported by the device (mV).</Description>
            </Property>
            <Property>
               <Name>maxADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If maxADCValue doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'maxADCValue') )
        obj.DriverData.maxADCValue = [ ];
    else
        propertyValue = obj.DriverData.maxADCValue;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="32767.0" Min="32767.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>32767</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The maximum ADC count for the device.</Description>
            </Property>
            <Property>
               <Name>maxSamplingRate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If maxSamplingRate doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'maxSamplingRate') )
        obj.DriverData.maxSamplingRate = [ ];
    else
        propertyValue = obj.DriverData.maxSamplingRate;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum single shot sampling rate for the device (samples per second).</Description>
            </Property>
            <Property>
               <Name>numberOfSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If numberOfSamples doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'numberOfSamples') )
        numberOfSamples = [ ];
    else
        propertyValue = obj.DriverData.numberOfSamples;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numberOfSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to be collected (applies to block and streaming mode capture).</Description>
            </Property>
            <Property>
               <Name>unitHandle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If DriverData.unitHandle doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'unitHandle') )
        obj.DriverData.unitHandle = [ ];
    else
        propertyValue = obj.DriverData.unitHandle;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The handle for the device.</Description>
            </Property>
            <Property>
               <Name>unitSerial</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If DriverData.unitSerial doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'unitSerial') )
        obj.DriverData.unitSerial = [ ];
    else
        propertyValue = obj.DriverData.unitSerial;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>''</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The batch/serial serial number of the device.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>getLastError</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function getLastError(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    stringLength = 0;
    errorCode = 0;
    infoString = '  ';

    [stringLength, errorCode] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), ...
                    evalin('base', 'ps2000Enuminfo.enPS2000Info.PS2000_ERROR_CODE'));

    % Read in error codes
    errorCodes = evalin('base', 'ps2000Enuminfo.enPS2000Error');

    switch (str2num(errorCode))

        case errorCodes.PS2000_OK

            disp('Status: OK');

        case errorCodes.PS2000_MAX_UNITS_OPENED

            error('The maximum number of units have been opened.');

        case errorCodes.PS2000_MEM_FAIL

            error('Not enough memory could be allocated on the host machine.');

        case errorCodes.PS2000_NOT_FOUND

            error('An oscilloscope could not be found.');

        case errorCodes.PS2000_FW_FAIL

            error('Unable to download firmware..');

        case errorCodes.PS2000_NOT_RESPONDING

            error('The oscilloscope is not responding to commands from the PC.');

        case errorCodes.PS2000_CONFIG_FAIL

            error('The configuration information in the oscilloscope has become corrupt or is missing.');

        case errorCodes.PS2000_OS_NOT_SUPPORTED

            error('The operating system is not supported by this driver.');

        case errorCodes.PS2000_PICOPP_TOO_OLD

            error('The PICOPP File is too old.');

    end

    clear stringLength;
    clear errorCodes;</MCode>
               </Code>
               <Description>getLastError(obj) returns the last error from the device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_get_unit_info function please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>getUnitInfo</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [unitInfo, stringLengths] = getUnitInfo(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Record of 
    stringLengths = zeros(8, 1);
    unitInfo = [];

    % Obtain unit information
    for infoValue = 0:7

        infoString = blanks(40);

        switch(infoValue)

            % Driver Version
            case 0

                [stringLengths(1), unitInfo.driverVersion] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % USB Version
            case 1

                [stringLengths(2), unitInfo.usbVersion] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % Hardware Version    
            case 2

                [stringLengths(3), unitInfo.hardwareVersion] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % Variant
            case 3

                [stringLengths(4), unitInfo.variant] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % Batch and Serial    
            case 4

                [stringLengths(5), unitInfo.batchAndSerial] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % Calibration Date    
            case 5

                [stringLengths(6), unitInfo.calibrationDate] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % Error Code    
            case 6

                [stringLengths(7), unitInfo.errorCode] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            % Kernel Driver Version
            case 7

                [stringLengths(8), unitInfo.kernelDriverVersion] = ...
                    calllib('ps2000', 'ps2000_get_unit_info', obj.DriverData.unitHandle, ...
                    infoString, length(infoString), infoValue);

            otherwise

                % Do nothing

        end

    end</MCode>
               </Code>
               <Description>getUnitInfo(obj) provides the following information about the oscilloscope:

1. Driver Version
2. USB Version
3. Hardware Version
4. Variant Information
5. Batch and Serial number
6. Calibration Date
7. Error code
8. Kernel Driver Version

If the oscilloscope failed to open, only line types 1 and 7 are available to explain why the last open unit call failed.

Input parameters:

obj - the object representing the device.

Output parameters:

unitInfo - a structure representing the unit information

stringLengths - an array of string lengths returned for the corresponding information line.


 
</Description>
            </Method>
            <Method>
               <Name>ps2000FlashLed</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000FlashLed(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps2000', 'ps2000_flash_led', obj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>ps2000FlashLed(obj) flashes the LED on the front of the oscilloscope (or in the pushbutton, for the PicoScope 2104 and 2105 oscilloscopes) three times and returns within one second.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_flash_led function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000LastButtonPress</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function buttonPress = ps2000LastButtonPress(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if(strcmp(obj.InstrumentModel, PS2000Constants.MODEL_PS2104) || ...
            strcmp(obj.InstrumentModel, PS2000Constants.MODEL_PS2105)

        buttonPress = calllib('ps2000', 'ps2000_last_button_press', obj.DriverData.unitHandle));

    else

        error('ps2000LastButtonPress - Function only supported by PicoScope 2104 and 2105.');
        buttonPress = 0;

    end</MCode>
               </Code>
               <Description>ps2000LastButtonPress(obj) returns the last registered state of the pushbutton on the PicoScope 2104 or 2105 PC Oscilloscope and then resets the status to zero.

This function may be used with the Test and Measurement Tool.

Returns:

0: no button press registered
1: short button press registered
2: long button press registered

Input parameters:

obj - the object representing the device.

Output parameters:

buttonPress - 0, if no button press has been registered
		 1, if short button press is registered
		 2, if long button press is registered

For further information on the ps2000_last_button_press function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000SetChannel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000SetChannel(obj, channel, enabled, dc, range)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if(obj.DriverData.firstRange &lt; obj.DriverData.lastRange &amp;&amp; ...
            (range &lt; obj.DriverData.firstRange || range &gt; obj.DriverData.lastRange))

        error('ps2000SetChannel: Specified voltage range index is invalid. Please try again.');

    % Cover case if user changes first range and last range. 
    elseif(obj.DriverData.firstRange &gt; obj.DriverData.lastRange)

        % Set Defaults
        invoke(obj, 'resetDevice');

        error('ps2000SetChannel: Voltage indices for firstRange and lastRange are incorrect. Setting defaults.');

    else
    
        status = calllib('ps2000', 'ps2000_set_channel', obj.DriverData.unitHandle, ...
                channel, enabled, dc, range);
            
        % Obtain channel settings information 
        channelSettings = obj.DriverData.channelSettings;

        if(status ~= 0)

            % Set the internal parameters of the driver    
            switch(channel)

                % Channel A
                case evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_A')

                    channelSettings(1,1) = enabled;
                    channelSettings(1,2) = dc;
                    channelSettings(1,3) = range;

                % Channel B
                case evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_B')

                    if(obj.DriverData.channelCount == PicoConstants.DUAL_SCOPE)

                        channelSettings(2,1) = enabled;
                        channelSettings(2,2) = dc;
                        channelSettings(2,3) = range;

                    end

                otherwise

                    % Invalid channel
                    error('ps2000SetChannel: Invalid channel selected');

            end
           
            obj.DriverData.channelSettings = channelSettings;
            
            % Array to store enabled states to pass to the driver
            
            enabledChannels = zeros(PicoConstants.DUAL_SCOPE, 1);
            
            enabledChannels(1) = channelSettings(1,1);
            
            if(obj.DriverData.channelCount == PicoConstants.DUAL_SCOPE)
                
               enabledChannels(2) = channelSettings(2,1);
                
            end
            
            calllib('ps2000Wrap', 'setEnabledChannels', obj.DriverData.unitHandle, ...
                enabledChannels);

        else

            error('ps2000SetChannel - unable to set channel.');

        end

    end

</MCode>
               </Code>
               <Description>ps2000SetChannel(obj, channel, enabled, dc, range) specifies if a channel is to be enabled, the AC/DC coupling mode and the input range.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_set_channel function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000SetLed</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000SetLed(obj, state)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (strcmp(obj.InstrumentModel, PS2000Constants.MODEL_PS2104) || ...
            strcmp(obj.InstrumentModel, PS2000Constants.MODEL_PS2105))

        status = calllib('ps2000', 'ps2000_set_led', obj.DriverData.unitHandle, state);

    else

        status = 0;
        error('Function only supported by PicoScope 2104 and 2105.');

    end</MCode>
               </Code>
               <Description>ps2000SetLed(obj, state) turns the LED on a handheld oscilloscope on and off, and controls its colour.

This function applies to the PicoScope 2104 and 2105 ONLY.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

state: should be one of -

	3: off
	1: red
	2: green

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_set_led  function please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000SetLight</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000SetLight(obj, state)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (strcmp(obj.InstrumentModel, PS2000Constants.MODEL_PS2104) || ...
            strcmp(obj.InstrumentModel, PS2000Constants.MODEL_PS2105))
        
        status = calllib('ps2000', 'ps2000_set_light', obj.DriverData.unitHandle, state);

    else

        status = 0;
        error('Function only supported by PicoScope 2104 and 2105.');

    end</MCode>
               </Code>
               <Description>ps2000SetLight(obj, state) controls the white light that illuminates the probe tip on a handheld oscilloscope.

This function applies to the PicoScope 2104 and 2105 ONLY.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

state - set to one of the following:

	0: light off
	1: light on
	
Output parameters:

status - status code returned by the driver.

For further information on the ps2000_set_light function please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000Stop</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000Stop(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps2000', 'ps2000_stop', obj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>ps2000Stop(obj) stop the oscilloscope sampling data. If this function is called before a trigger event occurs, the oscilloscope may not contain valid data.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_stop function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>resetDevice</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function resetDevice(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    disp('Setting Device Parameters...');

    % Set device parameters
    switch(obj.InstrumentModel)

        case PS2000Constants.MODEL_PS2104

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_100MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2104_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.SINGLE_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.FALSE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_NONE;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.ddsFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.FALSE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_8KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_50MSPS;

        case PS2000Constants.MODEL_PS2105

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_100MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2105_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.SINGLE_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.FALSE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_NONE;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.ddsFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.FALSE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_24KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_100MSPS;

        case PS2000Constants.MODEL_PS2202

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_100MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2200_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.FALSE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_NONE;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.ddsFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.hasEts = PicoConstants.FALSE;
            obj.DriverData.hasFastStreaming = PicoConstants.FALSE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_20MSPS;

        case PS2000Constants.MODEL_PS2203

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_50MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2000_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.TRUE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_4KS;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_2MHZ;
            obj.DriverData.ddsFrequency = PS2000Constants.PS2000_AWG_DDS_FREQUENCY;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.TRUE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_8KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_40MSPS;

        case PS2000Constants.MODEL_PS2204

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_50MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2000_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.TRUE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_4KS;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_2MHZ;
            obj.DriverData.ddsFrequency = PS2000Constants.PS2000_AWG_DDS_FREQUENCY;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.TRUE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_8KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_200MSPS;

        case PS2000Constants.MODEL_PS2205

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_50MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2000_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.TRUE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_4KS;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_2MHZ;
            obj.DriverData.ddsFrequency = PS2000Constants.PS2000_AWG_DDS_FREQUENCY;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.TRUE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_16KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_200MSPS;

        case PS2000Constants.MODEL_PS2204A

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_50MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2000_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.TRUE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_4KS;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_2MHZ;
            obj.DriverData.ddsFrequency = PS2000Constants.PS2000_AWG_DDS_FREQUENCY;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.TRUE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_8KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_200MSPS;

        case PS2000Constants.MODEL_PS2205A

            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_50MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2000_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.TRUE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_4KS;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_2MHZ;
            obj.DriverData.ddsFrequency = PS2000Constants.PS2000_AWG_DDS_FREQUENCY;
            obj.DriverData.hasEts = PicoConstants.TRUE;
            obj.DriverData.hasFastStreaming = PicoConstants.TRUE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_16KS;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_200MSPS;

        otherwise

            error('Unit not supported');

            obj.InstrumentModel = PS2000Constants.MODEL_NONE;
            obj.DriverData.firstRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_100MV');
            obj.DriverData.lastRange = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_20V');
            obj.DriverData.maxTimebase = PS2000Constants.PS2105_MAX_TIMEBASE;
            obj.DriverData.timebases = obj.DriverData.maxTimebase + 1;
            obj.DriverData.channelCount = PicoConstants.SINGLE_SCOPE;
            obj.DriverData.hasAdvancedTrigger = PicoConstants.FALSE;
            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_NONE;
            obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.ddsFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
            obj.DriverData.hasEts = PicoConstants.FALSE;
            obj.DriverData.hasFastStreaming = PicoConstants.FALSE;
            obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_ZERO;
            obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_ZERO;

    end

    % Set the max ADC value
    obj.DriverData.maxADCValue = PS2000Constants.PS2000_MAX_VALUE;
    
    % Reset Channels
    [status] = invoke(obj, 'setChannelDefaults');
    
    % Obtain Block group object
    blockGroupObj = get(obj, 'Block');
    blockGroupObj = blockGroupObj(1);

    % Turn off ETS
    if(obj.DriverData.hasEts == PicoConstants.TRUE)

        disp('Turning off Equivalent Time Sampling...');
        sampleTimePs = invoke(blockGroupObj, 'ps2000SetEts', evalin('base', ...
                            'ps2000Enuminfo.enPS2000EtsMode.PS2000_ETS_OFF'), 0, 0);

    end

    % Turn off trigger

    disp('Turning off trigger...');
    
    % Obtain Trigger group object
    
    triggerGroupObj = get(obj, 'Trigger');
    triggerGroupObj = triggerGroupObj(1);
    
    triggerSource = evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_NONE');
    
    obj.DriverData.delay = 0;
    obj.DriverData.autoTriggerMs = 0;
    
    triggerStatus = invoke(triggerGroupObj, 'setSimpleTrigger', triggerSource, 0, 0);

    fprintf('\nDefault data collection parameters:-\n\n');
    
    % Set the default number of samples
    obj.DriverData.numberOfSamples = 1024;
    fprintf('       Number of samples: %d\n', obj.DriverData.numberOfSamples);

    % Set the timebase - closest to 1ms
    maxBlockSamples = 0;
    [samplingIntervalMs, maxBlockSamples] = invoke(blockGroupObj, 'setBlockIntervalMs', 1);
    fprintf(' Block sampling interval: %.2f ms\n', samplingIntervalMs);

    % Set oversampling factor
    obj.DriverData.oversample = 1;
    fprintf('     Oversampling factor: %d\n\n', obj.DriverData.oversample);
    
    % Set streaming mode parameters
    [samplingIntervalUs, maxBlockSamples] = invoke(blockGroupObj, 'setBlockIntervalUs', 1);
    
    obj.DriverData.streamingIntervalMs = double(samplingIntervalUs / 1000);
    obj.DriverData.overviewBufferSize = 15000;
    obj.DriverData.autoStop = PicoConstants.TRUE;
    
    fprintf('Default Streaming mode parameters:-\n\n');

    fprintf('    Sampling interval: %.3f ms\n', obj.DriverData.streamingIntervalMs);
    fprintf(' Overview buffer size: %d samples\n', obj.DriverData.overviewBufferSize);
    fprintf('  Streaming auto stop: %d\n\n', obj.DriverData.autoStop);
    
    if(obj.DriverData.sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN || ...
            obj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)
       
        fprintf('Default Signal generator parameters:-\n\n');
        
        obj.DriverData.startFrequency = 1000;
        obj.DriverData.stopFrequency = 1000;
        obj.DriverData.offsetVoltage = 0;
        obj.DriverData.peakToPeakVoltage = 2000;
        
        fprintf('      Start frequency: %d Hz\n', obj.DriverData.startFrequency);
        fprintf('       Stop frequency: %d Hz\n', obj.DriverData.stopFrequency);
        fprintf('       Offset voltage: %d mV\n', obj.DriverData.offsetVoltage);
        fprintf(' Peak to Peak voltage: %d mV\n', obj.DriverData.peakToPeakVoltage);
    
    else
        
        obj.DriverData.startFrequency = 0;
        obj.DriverData.stopFrequency = 0;
        obj.DriverData.offsetVoltage = 0;
        obj.DriverData.peakToPeakVoltage = 0;
        
    end
    
    fprintf('\n');
    disp('Initialisation complete.');</MCode>
               </Code>
               <Description>resetDevice(obj) applies the default settings for the devices and turns off Equivalent Time Sampling mode. 
Use in cases where object properties are modified where they are not meant to be edited.

This function may be used with the Test and Measurement Tool.</Description>
            </Method>
            <Method>
               <Name>setChannelDefaults</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = setChannelDefaults(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    fprintf('Default Channel Setup:-\n\n');

    chA = evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_A');
    range5V = evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_5V');
    true = PicoConstants.TRUE;
    false = PicoConstants.FALSE;
    
    % Matrix of values to represent channels (rows) x properties (cols)
    obj.DriverData.channelSettings = zeros(obj.DriverData.channelCount, 3);
    
    % Create a num channels x fields array for temporary use
    chSettings = zeros(obj.DriverData.channelCount, 3);
    
    % Set Channel A and B, updating internal settings
    % Parameters are channel index, enabled, dc coupling, and range index
    
    for ch = 1:obj.DriverData.channelCount
        
        channelSettings(ch).enabled = true;
        channelSettings(ch).dc = true;
        channelSettings(ch).range = range5V;
        
        % Transpose the resulting array for the channel and combine
        chSettings(ch, :) = cell2mat(struct2cell(channelSettings(ch)))';
    
    end
    
    % Assign resulting matrix to object's DriverData.channelSettings
    % property
    obj.DriverData.channelSettings = chSettings;
    
    status = zeros(obj.DriverData.channelCount, 1);
    
    status(1) = invoke(obj, 'ps2000SetChannel', chA, true, true, range5V);
    fprintf('Channel A:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\n');

    clear chA;

    % Channel B
    if(obj.DriverData.channelCount == PicoConstants.DUAL_SCOPE)

        chB = evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_B');
        
        status(2) = invoke(obj, 'ps2000SetChannel', chB, true, true, range5V);
        fprintf('Channel B:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\n');

        clear chB;

    end</MCode>
               </Code>
               <Description>setChannelDefaults(obj) sets Channel A (and Channel B if available) to the following default values:

Enabled: True
Coupling: DC
Voltage Range: 5V

This function may be used with the Test and Measurement Tool.

Inputs:

obj - the device object.

Returns:

status - an array containing elements corresponding to the status code for setting each channel on the device.</Description>
            </Method>
            <Method>
               <Name>setChannels</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [chAStatus, chBStatus] = setChannels(obj, channelSettings)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Set Channel A

    chA = evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_A');

    chAStatus = invoke(obj, 'ps2000SetChannel', chA, channelSettings.channelA.enabled, ...
                    channelSettings.channelA.dc, channelSettings.channelA.range);

    clear chA;

    % Set Channel B
    if(obj.DriverData.channelCount == PicoConstants.DUAL_SCOPE)

        chB = evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_B');

        chBStatus = invoke(obj, 'ps2000SetChannel', chB, channelSettings.channelB.enabled, ...
                    channelSettings.channelB.dc, channelSettings.channelB.range);

        clear chB;
        
    else

        chBStatus = [];

    end
    
    </MCode>
               </Code>
               <Description>setChannels(obj, channelSettings) can be used to set the channels where the device has two channels. channelSettings is a structure with the following elements per channel:

- enabled
- DCCoupled (coupling)
- range

An example for channelSettings would be:

channelSettings.channelA.enabled = data.TRUE;
channelSettings.channelA.dc = data.TRUE;
channelSettings.channelA.range = ps2000Enuminfo.enPS2000Range.PS2000_1V;

channelSettings.channelB.enabled = data.FALSE;
channelSettings.channelB.dc = data.TRUE;
channelSettings.channelB.range = ps2000Enuminfo.enPS2000Range.PS2000_1V;

If the device has two channels, both channels are set, otherwise, ch_b_status is set to [].

</Description>
            </Method>
            <Method>
               <Name>setTimebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [timeIntervalNs, timeUnits1, maxSamples1] = setTimebase(obj, timebase)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    timeInterval = 0;
    timeUnits = 0;
    maxSamples = obj.DriverData.numberOfSamples;

    if(timebase &lt; 0 || timebase &gt; obj.DriverData.timebase)

        error('Timebase index out of range - use getTimebases to view available timebases.');

        % Return 0 if there is an error
        timeIntervalNs = 0;
        timeUnits1 = 0;
        maxSamples = 0;

    else

        [status, timeIntervalNs, timeUnits1, maxSamples1] = calllib('ps2000', ...
            'ps2000_get_timebase', obj.DriverData.unitHandle, i, ...
            obj.DriverData.numberOfSamples, timeInterval, timeUnits, ...
            obj.DriverData.oversample, maxSamples);

        if(status == 1)

            % Assign in case current timebase value stored in driver is
            % different.
            obj.DriverData.timebase = timebase;

            % Set the time units for later
            obj.DriverData.timeUnits = timeUnits1;

            fprintf('Time interval Interval: %d ns, Max samples: %d, Time units: %s', ...
                timebase, maxSamples1, timeunits(timeUnits1));

        else

            % Return 0 if there is an error
            timeIntervalNs = 0;
            timeUnits1 = 0;
            maxSamples = 0;

            error('Invalid timebase - use getTimebases to view available timebases.');

        end

    end

</MCode>
               </Code>
               <Description>setTimebase(obj, timebase) queries the driver with the timebase index to set the timebase and time units for the time values 
(when collecting data), returning the time interval (ns) and maximum number of samples as well.

Input parameters:

obj - the object representing the device.
timebase - the timebase index to set (between 0 and the maximum timebase for the oscilloscope)

Output parameters:

status - status code returned by the driver.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>block</Name>
         <Description>The Block group contains a set of properties and functions related to the block mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Block1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>blockIntervalNs</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If blockIntervalNs doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'blockIntervalNs') )
        deviceObj.DriverData.blockIntervalNs = [ ];

    else

         propertyValue = deviceObj.DriverData.blockIntervalNs;

    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.blockIntervalNs = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>5</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>blockIntervalNs is the sampling interval (in nanoseconds) when data is to be captured in block mode. DO NOT EDIT DIRECTLY - use the setBlockIntervalXX functions accordingly.</Description>
            </Property>
            <Property>
               <Name>maxTimebase</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If maxTimebase doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'maxTimebase') )
        deviceObj.DriverData.maxTimebase = [ ];
    else
        propertyValue = deviceObj.DriverData.maxTimebase;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="23.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>19</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The timebase index corresponding to the maximum time interval between samples.</Description>
            </Property>
            <Property>
               <Name>oversample</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If oversample doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'oversample') )
        deviceObj.DriverData.oversample = [ ];
    else
        propertyValue = deviceObj.DriverData.oversample;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.oversample = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="256.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The oversampling factor.</Description>
            </Property>
            <Property>
               <Name>timebase</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If timebase doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'timebase') )
        deviceObj.DriverData.timebase = 8;
    else
        propertyValue = deviceObj.DriverData.timebase;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.timebase = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>8</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The timebase index for the device - please refer to the main Programmer's Guide for further information.</Description>
            </Property>
            <Property>
               <Name>timebases</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If timebases doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'timebases') )
        
        deviceObj.DriverData.timebase = ...
            evalin('base', 'PS2000Constants.PS2200_MAX_TIMEBASE');
        
    else
        propertyValue = deviceObj.DriverData.timebases;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.timebases = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="23.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of timebases available for the device.</Description>
            </Property>
            <Property>
               <Name>timeUnits</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If timeUnits doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'timeUnits') )

        deviceObj.DriverData.timeUnits = 0;

    else

        propertyValue = deviceObj.DriverData.timeUnits;

    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.timeUnits = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The unit used to express sample times when times are returned from the driver on sample collection.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>getBlockData</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [bufferTimes, bufferChA, bufferChB, numDataValues, overflow, timeIndisposedMs] = getBlockData(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
 
    % Obtain the parent object and it's unitHandle property
    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    % Obtain channel settings array (channel x data field) matrix
    channelSettings = deviceObj.DriverData.channelSettings;

    % Pointers to data buffers
    pBufferTimes = libpointer; 
    pBufferChA = libpointer;
    pBufferChB = libpointer;

    % Set data buffers
    bufferTimes = [];
    bufferChA = []; 
    bufferChB = [];

    numDataValues = 0; % Number of data values per channel
    timeIndisposed = 0;

    % String to hold error message
    getBlockErrorStr = char('');

    % Run block
    [runBlockStatus, timeIndisposedMs] = calllib('ps2000', 'ps2000_run_block', ...
        unitHandle, deviceObj.DriverData.numberOfSamples, deviceObj.DriverData.timebase, ...
        deviceObj.DriverData.oversample, timeIndisposed);

    if(runBlockStatus == 0)

        getBlockErrorStr = char('getBlockData - ps2000_run_block: One or more parameters out of range.');

    else

        readyStatus = 0;

        % Poll the driver

        while(readyStatus == 0)

            readyStatus = calllib('ps2000', 'ps2000_ready', unitHandle);

        end

        if(readyStatus == -1)

            getBlockErrorStr = char('getBlockData - ps2000_ready: USB cable may have been unplugged.');

        else

            % Set up the buffers
            pBufferTimes = libpointer('int32Ptr', zeros(deviceObj.DriverData.numberOfSamples, 1));

            % Setup channel A if enabled
            if(channelSettings(1,1) == PicoConstants.TRUE)

                pBufferChA = libpointer('int16Ptr', zeros(deviceObj.DriverData.numberOfSamples, 1));

            end

            % Set up Channel B if there are two channels and if it is enabled

            if(deviceObj.DriverData.channelCount == PicoConstants.DUAL_SCOPE &amp;&amp; ...
                    channelSettings(2,1) == PicoConstants.TRUE)

                pBufferChB = libpointer('int16Ptr', zeros(deviceObj.DriverData.numberOfSamples, 1));

            end

            overflow = 0;
            overflowPtr = libpointer('int16Ptr', 0);

            % Get times and values
            numDataValues = calllib('ps2000', 'ps2000_get_times_and_values', ...
                                unitHandle, pBufferTimes, pBufferChA, pBufferChB, ...
                                [], [], overflowPtr, deviceObj.DriverData.timeUnits, ...
                                deviceObj.DriverData.numberOfSamples);

            % Indicate if parameters out of range or incorrect time units
            if(numDataValues == 0)

                getBlockErrorStr = char('getBlockData - ps2000_get_times_and_values: One or more parameters out of range or timeUnits incorrect');

            else

                % Output to buffers and convert channel data to milliVolts

                bufferTimes = get(pBufferTimes, 'Value');

                if(channelSettings(1,1) == PicoConstants.TRUE)

                    chARange = channelSettings(1,3);
                
                    bufferChA = adc2mv(pBufferChA.Value, PicoConstants.SCOPE_INPUT_RANGES(chARange + 1), ...
                                    deviceObj.DriverData.maxADCValue);

                end

                if(deviceObj.DriverData.channelCount == PicoConstants.DUAL_SCOPE &amp;&amp; ...
                    channelSettings(2,1) == PicoConstants.TRUE)
                    
                    chBRange = channelSettings(2,3);
                
                    bufferChB = adc2mv(pBufferChB.Value, PicoConstants.SCOPE_INPUT_RANGES(chBRange + 1), ...
                                    deviceObj.DriverData.maxADCValue);

                end
                
                overflow = overflowPtr.Value;

            end

        end

        % Indicate if there is an error
        if(isempty(getBlockErrorStr) == 0)

            error(getBlockErrorStr);

        end

    end</MCode>
               </Code>
               <Description>getBlockData(obj) instructs the device to collect a block of data and returns an array of times, array(s) of data values for channel A and/or for channel B, along with the number of samples per channel and the time for which the device was collecting data. 

This function may be used with the Test and Measurement Tool to collect data.

Input parameters:

obj - the object representing the Block group.

Output parameters:

bufferTimes - a buffer of sample times in the units specified.

bufferChA - buffer that receives data from Channel A (in milliVolts)

bufferChB -  buffer that receives data from Channel B (in milliVolts)

numDataValues - the number of data values obtained.

overflow - a bit pattern indicating whether an overflow has occurred and, if so, on which channel.

timeIndisposedMs - the approximate time, in milliseconds, that the ADC will take to collect data.

If a channel is not enabled, it's buffer will be returned as a [] matrix.

For further information on the underlying ps2000_run_block, ps2000_ready and ps2000_get_times_and_values functions please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>getTimebases</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function timebases = getTimebases(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    % Obtain the parent object and it's unitHandle property
    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    % Return a String array and output the available timebases to the display.
    timeInterval = 0;
    timeUnits = 0;
    maxSamples = deviceObj.DriverData.numberOfSamples;

    % Create a cell to show the timebase index, the time interval and the
    % units.
    timebases = cell(deviceObj.DriverData.timebases, 1);

    fprintf('Available timebases for device:\n\n');

    for i = 0:(deviceObj.DriverData.timebases - 1)

        [status, timeInterval1, timeUnits1, maxSamples1] = calllib('ps2000', ...
            'ps2000_get_timebase', unitHandle, i, ...
            deviceObj.DriverData.numberOfSamples, timeInterval, timeUnits, ...
            deviceObj.DriverData.oversample, maxSamples);

        % Only output valid timebases
        if(status == 1)

            timeUnitsStr = timeunits(timeUnits1);

            timebaseStr = sprintf('Timebase %2d:- Interval: %7d ns \tMax Samples: %d\tTime units: %d (%s)\n', ...
                i, timeInterval1, maxSamples1, timeUnits1, timeUnitsStr);

            fprintf(timebaseStr);

            timebases(i + 1, 1) = cellstr(timebaseStr);

        end

    end</MCode>
               </Code>
               <Description>getTimebases(obj) returns a string array and outputs the available timebases to the display.

Input parameters:

obj - the object representing the Block group.

Output parameters:

timebases - a string of timebases.

For further information on the ps2000_get_timebase function please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000SetEts</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function sampleTimePs = ps2000SetEts(obj, mode, etsCycles, etsInterleave)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(strcmp(deviceObj.InstrumentModel, PS2000Constants.MODEL_PS2202) || ...
            strcmp(deviceObj.InstrumentModel, PS2000Constants.MODEL_NONE))

        error('ETS functionality not supported by this device.');

    else

        sampleTimePs = calllib('ps2000', 'ps2000_set_ets', deviceObj.DriverData.unitHandle, ...
                        mode, etsCycles, etsInterleave);

        % Inform user if parameter incorrect
        if(sampleTimePs == 0 &amp;&amp; mode ~= 0)

            switch(deviceObj.InstrumentModel)

                case PS2000Constants.MODEL_PS2104

                    if(etsCycles &lt; 0 || etsCycles &gt; PS2000Constants.PS2104_MAX_ETS_CYCLES)

                        error('ps2000SetEts: ETS Cycles out of range (Max: 125).')

                    elseif(etsInterleave &lt; 0 || etsInterleave &gt; PS2000Constants.PS2104_MAX_ETS_INTERLEAVE)

                        error('ps2000SetEts: ETS Interleave out of range. (Max: 25)')

                    else

                        etsRatio = etsCycles / etsInterleave;

                        if(etsRatio &lt; PS2000Constants.PS2000_MIN_ETS_CYCLES_INTERLEAVE_RATIO || ...
                                etsRatio &gt; PS2000Constants.PS2000_MAX_ETS_CYCLES_INTERLEAVE_RATIO)

                            error('ps2000Ets: ETS Ratio must be between 1 and 10.');

                        end

                    end

                case PS2000Constants.MODEL_PS2105

                    if(etsCycles &lt; 0 || etsCycles &gt; PS2000Constants.PS2105_MAX_ETS_CYCLES)

                        error('ps2000SetEts: ETS Cycles out of range (Max: 250).')

                    elseif(etsInterleave &lt; 0 || etsInterleave &gt; PS2000Constants.PS2105_MAX_ETS_INTERLEAVE)

                        error('ps2000SetEts: ETS Interleave out of range. (Max: 50)')

                    else

                        etsRatio = etsCycles / etsInterleave;

                        if(etsRatio &lt; PS2000Constants.PS2000_MIN_ETS_CYCLES_INTERLEAVE_RATIO || ...
                                etsRatio &gt; PS2000Constants.PS2000_MAX_ETS_CYCLES_INTERLEAVE_RATIO)

                            error('ps2000Ets: ETS Ratio must be between 1 and 10.');

                        end

                    end

                case PS2000Constants.MODEL_PS2203

                    if(etsCycles &lt; 0 || etsCycles &gt; PS2000Constants.PS2203_MAX_ETS_CYCLES)

                        error('ps2000SetEts: ETS Cycles out of range (Max: 250).')

                    elseif(etsInterleave &lt; 0 || etsInterleave &gt; PS2000Constants.PS2203_MAX_ETS_INTERLEAVE)

                        error('ps2000SetEts: ETS Interleave out of range. (Max: 50)')

                    else

                        etsRatio = etsCycles / etsInterleave;

                        if(etsRatio &lt; PS2000Constants.PS2000_MIN_ETS_CYCLES_INTERLEAVE_RATIO || ...
                                etsRatio &gt; PS2000Constants.PS2000_MAX_ETS_CYCLES_INTERLEAVE_RATIO)

                            error('ps2000Ets: ETS Ratio must be between 1 and 10.');

                        end

                    end

                case PS2000Constants.MODEL_PS2204

                    if(etsCycles &lt; 0 || etsCycles &gt; PS2000Constants.PS2204_MAX_ETS_CYCLES)

                        error('ps2000SetEts: ETS Cycles out of range (Max: 250).')

                    elseif(etsInterleave &lt; 0 || etsInterleave &gt; PS2000Constants.PS2204_MAX_ETS_INTERLEAVE)

                        error('ps2000SetEts: ETS Interleave out of range. (Max: 40)')

                    else

                        etsRatio = etsCycles / etsInterleave;

                        if(etsRatio &lt; PS2000Constants.PS2000_MIN_ETS_CYCLES_INTERLEAVE_RATIO || ...
                                etsRatio &gt; PS2000Constants.PS2000_MAX_ETS_CYCLES_INTERLEAVE_RATIO)

                            error('ps2000Ets: ETS Ratio must be between 1 and 10.');

                        end

                    end

                case PS2000Constants.MODEL_PS2205

                    if(etsCycles &lt; 0 || etsCycles &gt; PS2000Constants.PS2205_MAX_ETS_CYCLES)

                        error('ps2000SetEts: ETS Cycles out of range (Max: 250).')

                    elseif(etsInterleave &lt; 0 || etsInterleave &gt; PS2000Constants.PS2205_MAX_ETS_INTERLEAVE)

                        error('ps2000SetEts: ETS Interleave out of range. (Max: 40)')

                    else

                        etsRatio = etsCycles / etsInterleave;

                        if(etsRatio &lt; PS2000Constants.PS2000_MIN_ETS_CYCLES_INTERLEAVE_RATIO || ...
                                etsRatio &gt; PS2000Constants.PS2000_MAX_ETS_CYCLES_INTERLEAVE_RATIO)

                            error('ps2000Ets: ETS Ratio must be between 1 and 10.');

                        end

                    end

                otherwise

                    % Do nothing
            end

        elseif(sampleTimePs == 0 &amp;&amp; mode == 0)

            disp('ps2000SetEts: ETS switched off.')

        else

            disp('ps2000SetEts: ETS mode set.');

        end

    end</MCode>
               </Code>
               <Description>ps2000SetEts(obj, mode, ets_cycles, ets_interleave) is used to enable or disable ETS (equivalent time sampling) and to set the ETS parameters.

Input parameters:

obj - the object representing the Block group.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_set_ets function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setBlockIntervalMs</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [samplingIntervalMs, maxBlockSamples] = setBlockIntervalMs(obj, timeIntervalMs)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Convert milliseconds to nanoseconds
    timeIntervalNs = timeIntervalMs * 1e6;

    [samplingIntervalNs, maxBlockSamples] = invoke(obj, 'setBlockIntervalNs', timeIntervalNs);

    samplingIntervalMs = double(samplingIntervalNs / 1e6); </MCode>
               </Code>
               <Description>setBlockIntervalMs(obj, samplingIntervalMs) finds the timebase index corresponding to the requested sample interval (in milliseconds) and sets it in the driver using the setBlockIntervalNs function.

If a matching sample interval cannot be found, the timebase property will be set to the timebase index of the next sampling interval shorter than the requested sampling interval.

Input parameters:

obj - the object representing the Block group.
timeIntervalMs - the desired sampling interval, in milliseconds.

Output parameters:
 
samplingIntervalMs - the actual sampling interval, in milliseconds.
maxBlockSamples - the maximum number of samples available.</Description>
            </Method>
            <Method>
               <Name>setBlockIntervalNs</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [samplingIntervalNs, maxBlockSamples] = setBlockIntervalNs(obj, timeIntervalNs)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object and it's unitHandle property
    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    % variable to compare difference between requested sampling interval and 
    % sampling intervals provided by driver.
    intervalDifference = timeIntervalNs;

    selectedTimebase = [];

    timeInterval = 0;
    timeUnits = 0;
    oversample = 0;
    maxSamples = deviceObj.DriverData.numberOfSamples;

    % Loop through available timebases
    for i = 0:(deviceObj.DriverData.timebases - 1)

        [status, samplingIntervalNs, timeUnits1, maxSamples1] = calllib('ps2000', ...
            'ps2000_get_timebase', unitHandle, i, ...
            deviceObj.DriverData.numberOfSamples, timeInterval, timeUnits, oversample, maxSamples);

        % If the parameter combination is valid, update the selected
        % timebase, otherwise select the nearest sampling interval which
        % gives a faster sampling rate.
        if(status == 1)
            
            if(samplingIntervalNs == timeIntervalNs)
                
                selectedTimebase = i;
                break;
                                
            elseif(samplingIntervalNs &gt; timeIntervalNs)

                selectedTimebase = i - 1;
                break;

            end

        end

    end

    % Only assign timebase value if it is valid.
    if(isempty(selectedTimebase) == 0)

        [status, samplingIntervalNs, timeUnits1, maxSamples1] = calllib('ps2000', ...
            'ps2000_get_timebase', unitHandle, selectedTimebase, ...
            deviceObj.DriverData.numberOfSamples, timeInterval, timeUnits, oversample, maxSamples);
        
        samplingIntervalNs = double(samplingIntervalNs);
        
        deviceObj.DriverData.timebase = selectedTimebase;  
        deviceObj.DriverData.blockSamplingIntervalNs = samplingIntervalNs;
        deviceObj.DriverData.timeUnits = timeUnits1;
        maxBlockSamples = maxSamples1;
        
    else

        error('Invalid sampling time selected - use getTimebases to see available sampling intervals and corresponding timebases.')

    end</MCode>
               </Code>
               <Description>setBlockIntervalNs(obj, sampling_interval_ns) finds the timebase index corresponding to the requested sample interval (in nanoseconds) and sets the timebase property in the Instrument Driver.

If a matching sample interval cannot be found, the timebase property will be set to the timebase index of the next sampling interval shorter than the requested sampling interval.

Input parameters:

obj - the object representing the Block group.
timeIntervalNs - the desired sampling interval, in nanoseconds.

Output parameters:
 
samplingIntervalNs - the actual sampling interval, in nanoseconds.
maxBlockSamples - the maximum number of samples available.</Description>
            </Method>
            <Method>
               <Name>setBlockIntervalSeconds</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [samplingIntervalSeconds, maxBlockSamples = setBlockIntervalSeconds(obj, timeIntervalSeconds)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Convert seconds to nanoseconds
    timeIntervalNs = timeIntervalSeconds * 1e9;

    [samplingIntervalNs, maxBlockSamples] = invoke(obj, 'setBlockIntervalNs', timeIntervalNs);

    samplingIntervalSeconds = double(timeIntervalNs / 1e9);</MCode>
               </Code>
               <Description>setBlockIntervalS(obj, samplingIntervalSeconds) finds the timebase index corresponding to the required sample interval (in seconds) and sets it in the driver via the setBlockIntervalNs function.

If a matching sample interval cannot be found, the timebase property will be set to the timebase index of the next sampling interval shorter than the requested sampling interval.

Input parameters:

obj - the object representing the Block group.
timeIntervalSeconds - the desired sampling interval, in seconds.

Output parameters:
 
samplingIntervalS - the actual sampling interval, in seconds.
maxBlockSamples - the maximum number of samples available.</Description>
            </Method>
            <Method>
               <Name>setBlockIntervalUs</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [samplingIntervalUs, maxBlockSamples] = setBlockIntervalUs(obj, timeIntervalUs)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Convert microseconds to nanoseconds
    timeIntervalNs = timeIntervalUs * 1e3;

    [samplingIntervalNs, maxBlockSamples] = invoke(obj, 'setBlockIntervalNs', timeIntervalNs);

    samplingIntervalUs = double(samplingIntervalNs / 1e3); </MCode>
               </Code>
               <Description>setBlockIntervalUs(obj, sampling_interval_us) finds the timebase index corresponding to the required sample interval (in microseconds) and sets it in the driver via the setBlockIntervalNs function.

If a matching sampling interval cannot be found, the timebase property will be set as the timebase index corresponding to the fastest sampling interval that is closest to the desired sampling interval.

Input parameters:

obj - the object representing the Block group.
time_interval_ns - the desired sampling interval, in microseconds.

Output parameters:
 
samplingIntervalUs - the actual sampling interval, in microseconds.
maxBlockSamples - the maximum number of samples available.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>signalgenerator</Name>
         <Description>The Signalgenerator group contains a set of properties and functions related to the signal generator functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="SignalGenerator1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>awgBufferSize</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If awgBufferSize doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'awgBufferSize') )
        
        deviceObj.DriverData.awgBufferSize = 0;
    
    else
        
        propertyValue = deviceObj.DriverData.awgBufferSize;
    
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4096.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The size of the arbitrary waveform buffer on the device, in samples. Applies only to the PicoScope 2203, 2204, 2204A and 2205A (4096 samples).</Description>
            </Property>
            <Property>
               <Name>dacFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If DriverData.dacFrequency doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'dacFrequency') )
        
        deviceObj.DriverData.dacFrequency = [ ];
        
    else
        propertyValue = deviceObj.DriverData.dacFrequency;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>dacFrequency is the update frequency of the Arbitrary Waveform Generator (in Hz).</Description>
            </Property>
            <Property>
               <Name>ddsFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If DriverData.ddsFrequency doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'ddsFrequency') )
        
        deviceObj.DriverData.ddsFrequency = [ ];
        
    else
        
        propertyValue = deviceObj.DriverData.ddsFrequency;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>ddsFrequency is the direct digital synthesis frequency for the arbitrary waveform generator (in Hz).</Description>
            </Property>
            <Property>
               <Name>offsetVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If offsetVoltage doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'offsetVoltage') )
        
        deviceObj.DriverData.offsetVoltage = 0;
        
    else
        
        propertyValue = deviceObj.DriverData.offsetVoltage;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.offsetVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2000.0" Min="-2000.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The voltage offset, in milliVolts, to be applied to the waveform.

The sum of the offset voltage and peak to peak voltage should not exceed +/- 4000mV.</Description>
            </Property>
            <Property>
               <Name>peakToPeakVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If peakToPeakVoltage doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'peakToPeakVoltage') )
        
        deviceObj.DriverData.peakToPeakVoltage = 0;
        
    else
        
        propertyValue = deviceObj.DriverData.peakToPeakVoltage;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.peakToPeakVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The peak-to-peak voltage, in millivolts, of the waveform signal.

The sum of the peak to peak voltage and offset voltage should not exceed +/- 4000mV.</Description>
            </Property>
            <Property>
               <Name>sigGenType</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If sigGenType doesn't exist, create it.
    if ( ~isfield(obj.DriverData, 'sigGenType') )
        obj.DriverData.sigGenType = [ ];

    else 
         propertyValue = obj.DriverData.sigGenType;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The type of Signal Generator on the device:

0 - None
1 - Function Generator
2 - Arbitrary Waveform Generator</Description>
            </Property>
            <Property>
               <Name>startFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If startFrequency doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'startFrequency') )
        
        deviceObj.DriverData.startFrequency = 0;
        
    else
        
        propertyValue = deviceObj.DriverData.startFrequency;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.startFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="100000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency that the signal generator will initially produce (Hertz).

Note: The maximum output frequency is 100kHz (quoted for a sine wave). The minimum is 0 Hz (DC).</Description>
            </Property>
            <Property>
               <Name>stopFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If stopFrequency doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'stopFrequency') )

        deviceObj.DriverData.stopFrequency = 0;

    else

        propertyValue = deviceObj.DriverData.stopFrequency;

    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.stopFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="100000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency at which the sweep reverses direction or returns to the initial frequency (Hertz).

To output a signal with constant frequency, ensure that stopFrequency is equal to startFrequency.

Note: The maximum output frequency is 100kHz (quoted for a sine wave). The minimum is 0 Hz (DC).</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps2000SetSigGenArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000SetSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, sweeps)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object and it's unitHandle property
    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    startFrequency = deviceObj.DriverData.startFrequency;
    stopFrequency = deviceObj.DriverData.stopFrequency;
    offsetVoltage = deviceObj.DriverData.offsetVoltage;
    peakToPeakVoltage = deviceObj.DriverData.peakToPeakVoltage;
    
    if(deviceObj.DriverData.sigGenType == evalin('base', 'PicoConstants.SIG_GEN_AWG'))

        % Verify frequency
        if(startFrequency &lt; PS2000Constants.PS2000_MIN_SIGGEN_FREQ || ...
            startFrequency &gt; PS2000Constants.PS2000_MAX_SIGGEN_FREQ || ...
                stopFrequency &lt; PS2000Constants.PS2000_MIN_SIGGEN_FREQ || ...
                    stopFrequency &gt; PS2000Constants.PS2000_MAX_SIGGEN_FREQ)

            error('ps2000SetSigGenArbitrary: Frequencies must be in the range 0 -&gt; 100000Hz'); 

        end
        
        % Convert frequency to delta phase
        
        startDeltaPhase = freq2delta(startFrequency, length(arbitraryWaveform), ...
            deviceObj.DriverData.awgBufferSize, deviceObj.DriverData.ddsFrequency);
        
        stopDeltaPhase = freq2delta(stopFrequency, length(arbitraryWaveform), ...
            deviceObj.DriverData.awgBufferSize, deviceObj.DriverData.ddsFrequency);
        
        % Verify peak to peak voltage
        if( ( peakToPeakVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                peakToPeakVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) &amp;&amp; ...
                peakToPeakVoltage ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC'))

            error('ps2000SetSigGenArbitrary: Peak to peak voltage must be in the range 500 -&gt; 4000mV or 0');

        end

        % Verify offset voltage
        if(offsetVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_OFFSET_MV') || ...
            offsetVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_OFFSET_MV'))

            error('ps2000SetSigGenArbitrary: Offset voltage must be in the range -1000 to + 1000mV');

        end

        % Verify offset and peak to peak voltage

        if( ( (peakToPeakVoltage + offsetVoltage) &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                ( (peakToPeakVoltage + offsetVoltage) &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) ) &amp;&amp; ...
                    ( (peakToPeakVoltage + offsetVoltage) ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC') ) )

            error('ps2000SetSigGenArbitrary: Sum of peak to peak and offset voltages must be in the range 500 -&gt; 4000mV');

        end

        % Convert increment to delta phase
        
        deltaPhaseIncrement = freq2delta(increment, length(arbitraryWaveform), ...
            deviceObj.DriverData.awgBufferSize, deviceObj.DriverData.ddsFrequency);
        
        dwellCount = round(dwellTime * deviceObj.DriverData.ddsFrequency); % Round to the nearest integer
        
        % Check length of arbitrary waveform
        if(length(arbitraryWaveform) &gt; deviceObj.DriverData.awgBufferSize)
           
            error('ps2000SetSigGenArbitrary: Size of waveform exceeds AWG buffer size');
            
        end
        
        % Arbitrary waveform must be entered in range -1 to +1
        % corresponding to max/min value, convert to 0 -&gt; 255
        
        awgBuffer = zeros(length(arbitraryWaveform), 1);
        
        if(int32(max(arbitraryWaveform)) &gt; 1 || int32(min(arbitraryWaveform)) &lt; -1)
           
            error('ps2000SetSigGenArbitrary: Waveform amplitude should be in range -1 to + 1');
            
        else
            
            scaleFactor = double(intmax('uint8')) / 2;
            
            awgBuffer = uint8((arbitraryWaveform * scaleFactor) + scaleFactor);
            
        end

        % Call function converting offsetVoltage and peakToPeakVoltage to microVolts
        status = calllib('ps2000', 'ps2000_set_sig_gen_arbitrary', unitHandle, ...
                    (offsetVoltage * 1000), (peakToPeakVoltage * 1000), startDeltaPhase, ...
                        stopDeltaPhase, deltaPhaseIncrement, dwellCount, ...
                        awgBuffer, length(awgBuffer), sweepType, sweeps);

        % Check for error                
        if(status == 0)   

            invoke(deviceObj, 'getLastError');

        end
        
        clear startDeltaPhase;
        clear stopDeltaPhase;
        clear deltaPhaseIncrement; 
        clear dwellCount;
        clear awgBuffer;

    else

        error('ps2000SetSigArbitrary: Device does not have function generator.');

    end</MCode>
               </Code>
               <Description>ps2000SetSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, sweeps) programs the signal generator to produce an arbitrary waveform.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

The offsetVoltage, peakToPeakVoltage, startFrequency and stopFrequency Group properties should be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.

increment - the amount by which the frequency rises or falls every dwellTime
		seconds in sweep mode.

dwellTime - the time in seconds between frequency changes in sweep mode.

arbitraryWaveform - a buffer holding the waveform pattern as a set of samples (should be in the range 0 to 1).

sweepType - this should be one of the following:
			
		0 - Up
		1 - Down
		2 - Up -&gt; Down
		3 - Down -&gt; Up	

sweeps - the number of times to sweep the frequency.

Output parameters:

status - status code returned by the driver.

NOTE: Parameter types have been changed from the underlying ps2000SetSigGenArbitrary 
function. 

For further information on the underlying ps200_set_sig_gen_arbitrary function please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000SetSigGenBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000SetSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, sweeps)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.sigGenType == evalin('base', 'PicoConstants.SIG_GEN_AWG'))

        startFrequency = deviceObj.DriverData.startFrequency;
        stopFrequency = deviceObj.DriverData.stopFrequency;
        offsetVoltage = deviceObj.DriverData.offsetVoltage;
        peakToPeakVoltage = deviceObj.DriverData.peakToPeakVoltage;
        
        % Verify frequency
        if(startFrequency &lt; PS2000Constants.PS2000_MIN_SIGGEN_FREQ || ...
            startFrequency &gt; PS2000Constants.PS2000_MAX_SIGGEN_FREQ || ...
                stopFrequency &lt; PS2000Constants.PS2000_MIN_SIGGEN_FREQ || ...
                    stopFrequency &gt; PS2000Constants.PS2000_MAX_SIGGEN_FREQ)

            error('ps2000SetSigGenBuiltIn: Frequencies must be in the range 0 -&gt; 100000Hz'); 

        end

        % Verify peak to peak voltage
        if( ( peakToPeakVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                peakToPeakVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) &amp;&amp; ...
                peakToPeakVoltage ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC'))

            error('ps2000SetSigGenBuiltIn: Peak to peak voltage must be in the range 500 -&gt; 4000mV or 0');

        end

        % Verify offset voltage
        if(offsetVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_OFFSET_MV') || ...
            offsetVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_OFFSET_MV'))

            error('ps2000SetSigGenBuiltIn: Offset voltage must be in the range -1000 to + 1000mV');

        end

        % Verify offset and peak to peak voltage

        if( ( (peakToPeakVoltage + offsetVoltage) &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                ( (peakToPeakVoltage + offsetVoltage) &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) ) &amp;&amp; ...
                    ( (peakToPeakVoltage + offsetVoltage) ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC') ) )

            error('ps2000SetSigGenBuiltIn: Sum of peak to peak and offset voltages must be in the range 500 -&gt; 4000mV');

        end


        % Call function converting offsetVoltage and peakToPeakVoltage to microVolts
        status = calllib('ps2000', 'ps2000_set_sig_gen_built_in', ...
                    deviceObj.DriverData.unitHandle, (offsetVoltage * 1000), ...
                    (peakToPeakVoltage * 1000), waveType, startFrequency, ...
                    stopFrequency, increment, dwellTime, sweepType, sweeps);

        % Check for error                
        if(status == 0)   

            invoke(deviceObj, 'getLastError');

        end

    else

        error('ps2000SetSigGenBuiltIn: Device does not have function generator.');

    end</MCode>
               </Code>
               <Description>ps2000SetSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, sweeps) sets up the signal generator to produce a signal from a list of built-in waveforms. If the startFrequency and stopFrequency properties are different, the oscilloscope output will sweep either up, down or up and down.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

The offsetVoltage, peakToPeakVoltage, startFrequency and stopFrequency Group properties should be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
waveType - Use the following values to specify the built-in wavetype:

		0 - sine wave
		1 - square wave
		2 - triangle wave
		3 - Rising sawtooth
		4-  Falling sawtooth
		5 - DC voltage

increment - the amount by which the frequency rises or falls every dwellTime
		seconds in sweep mode.

dwellTime - the time in seconds between frequency changes in sweep mode.

sweepType - this should be one of the following:
			
		0 - Up
		1 - Down
		2 - Up -&gt; Down
		3 - Down -&gt; Up	

sweeps - the number of times to sweep the frequency.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_set_sig_gen_built_in function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrarySimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenArbitrarySimple(obj, arbitraryWaveform)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    startFrequency = deviceObj.DriverData.startFrequency;
    stopFrequency = deviceObj.DriverData.stopFrequency;
    offsetVoltage = deviceObj.DriverData.offsetVoltage;
    peakToPeakVoltage = deviceObj.DriverData.peakToPeakVoltage;

    % Only call function if device has an Arbitrary Waveform Generator
    if(deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        startFrequency = deviceObj.DriverData.startFrequency;
        
        if(startFrequency &lt; PS2000Constants.PS2000_MIN_SIGGEN_FREQ || ...
            startFrequency &gt; PS2000Constants.PS2000_MAX_SIGGEN_FREQ)

            error('setSigGenArbitrarySimple: Frequency must be in range 0 -&gt; 100000Hz'); 

        end
        
        % Convert frequency to delta phase
        
        startDeltaPhase = freq2delta(startFrequency, length(arbitraryWaveform), ...
            deviceObj.DriverData.awgBufferSize, deviceObj.DriverData.ddsFrequency);
        
        % Verify peak to peak voltage
        if( ( peakToPeakVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                peakToPeakVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) &amp;&amp; ...
                peakToPeakVoltage ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC'))

            error('ps2000SetSigGenArbitrary: Peak to peak voltage must be in the range 500 -&gt; 4000mV or 0');

        end

        % Verify offset voltage
        if(offsetVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_OFFSET_MV') || ...
            offsetVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_OFFSET_MV'))

            error('ps2000SetSigGenArbitrary: Offset voltage must be in the range -1000 to + 1000mV');

        end

        % Verify offset and peak to peak voltage

        if( ( (peakToPeakVoltage + offsetVoltage) &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                ( (peakToPeakVoltage + offsetVoltage) &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) ) &amp;&amp; ...
                    ( (peakToPeakVoltage + offsetVoltage) ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC') ) )

            error('ps2000SetSigGenArbitrary: Sum of peak to peak and offset voltages must be in the range 500 -&gt; 4000mV');

        end

        % Check length of arbitrary waveform
        if(length(arbitraryWaveform) &gt; deviceObj.DriverData.awgBufferSize)
           
            error('ps2000SetSigGenArbitrary: Size of waveform exceeds AWG buffer size');
            
        end
        
        % Arbitrary waveform must be entered in range -1 to +1
        % corresponding to max/min value, convert to 0 -&gt; 255
        
        awgBuffer = zeros(length(arbitraryWaveform), 1);
        
        if(int32(max(arbitraryWaveform)) &gt; 1 || int32(min(arbitraryWaveform)) &lt; -1)
           
            error('ps2000SetSigGenArbitrary: Waveform amplitude should be in range -1 to + 1');
            
        else
            
            scaleFactor = double(intmax('uint8')) / 2;
            
            awgBuffer = uint8((arbitraryWaveform * scaleFactor) + scaleFactor);
            
        end
        
        % Call function converting offsetVoltage and peakToPeakVoltage to microVolts
        status = calllib('ps2000', 'ps2000_set_sig_gen_arbitrary', unitHandle, ...
                    (offsetVoltage * 1000), (peakToPeakVoltage * 1000), startDeltaPhase, ...
                        startDeltaPhase, 0, 0, awgBuffer, length(awgBuffer), 0, 0);
        
                    status = invoke(obj, 'ps2000SetSigGenArbitrary', ...
                    0, 0, arbitraryWaveform, 0, 0);
                
        % Check for error                
        if(status == 0)   

            invoke(deviceObj, 'getLastError');

        end
       
    else
        
        error('setSigGenArbitrarySimple: Device does not have function generator.');
                
    end
</MCode>
               </Code>
               <Description>ps2000SetSigGenArbitrary(obj,  arbitraryWaveform) 
 programs the signal generator to produce an arbitrary waveform at a constant frequency.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

This function may be used with the Test and Measurement Tool.

The startFrequency property in the Signalgenerator group will be used for the output frequency. 

The offsetVoltage and peakToPeakVoltage Group properties should be set prior to calling this function.

Input parameters:

obj - the object representing the Signalgenerator group.
arbitraryWaveform - a buffer holding the waveform pattern as a set of samples (should be in the range 0 to 1).

Output parameters:

status - status code returned by the driver.

Please also refer to the ps200_set_sig_gen_arbitrary function in the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltInSimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltInSimple(obj, waveType)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    startFrequency = deviceObj.DriverData.startFrequency;
    offsetVoltage = deviceObj.DriverData.offsetVoltage;
    peakToPeakVoltage = deviceObj.DriverData.peakToPeakVoltage;

    if(deviceObj.DriverData.sigGenType ~= evalin('base', 'PicoConstants.SIG_GEN_NONE'))

        if(startFrequency &lt; PS2000Constants.PS2000_MIN_SIGGEN_FREQ || ...
            startFrequency &gt; PS2000Constants.PS2000_MAX_SIGGEN_FREQ)

            error('setSigGenBuiltInSimple: Frequency must be in range 0 -&gt; 100000Hz'); 

        end
        
        % Verify peak to peak voltage
        if( ( peakToPeakVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                peakToPeakVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) &amp;&amp; ...
                peakToPeakVoltage ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC'))

            error('ps2000SetSigGenBuiltIn: Peak to peak voltage must be in the range 500 -&gt; 4000mV or 0');

        end

        % Verify offset voltage
        if(offsetVoltage &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_OFFSET_MV') || ...
            offsetVoltage &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_OFFSET_MV'))

            error('ps2000SetSigGenBuiltIn: Offset voltage must be in the range -1000 to + 1000mV');

        end

        % Verify offset and peak to peak voltage

        if( ( (peakToPeakVoltage + offsetVoltage) &lt; evalin('base', 'PS2000Constants.PS2000_MIN_SIGGEN_PKTOPK_MV') || ...
                ( (peakToPeakVoltage + offsetVoltage) &gt; evalin('base', 'PS2000Constants.PS2000_MAX_SIGGEN_PKTOPK_MV') ) ) &amp;&amp; ...
                    ( (peakToPeakVoltage + offsetVoltage) ~= evalin('base', 'PS2000Constants.PS2000_SIGGEN_ZERO_VOLTAGE_DC') ) )

            error('ps2000SetSigGenBuiltIn: Sum of peak to peak and offset voltages must be in the range 500 -&gt; 4000mV');

        end

        
        % Call function converting offsetVoltage and peakToPeakVoltage to microVolts
        status = calllib('ps2000', 'ps2000_set_sig_gen_built_in', ...
                    deviceObj.DriverData.unitHandle, ...
                    (deviceObj.DriverData.offsetVoltage * 1000), ...
                    (deviceObj.DriverData.peakToPeakVoltage * 1000), ...
                    waveType, startFrequency, startFrequency, 0, 0, 0, 0);
        
        % Check for error                
        if(status == 0)   

            invoke(deviceObj, 'getLastError');

        end
                
    else

        error('setSigGenBuiltInSimple: Device does not have function generator.');

    end</MCode>
               </Code>
               <Description>setSigGenBuiltInSimple(obj, waveType) sets up the signal generator to produce a signal from a list of built-in waveforms at a constant frequency.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

The startFrequency property in the Signalgenerator group will be used for the output frequency.

The offsetVoltage and peakToPeakVoltage Group properties should be set prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
waveType - Use the following values to specify the built-in wavetype:

		0 - sine wave
		1 - square wave
		2 - triangle wave
		3 - Rising sawtooth
		4-  Falling sawtooth
		5 - DC voltage

Output parameters:

status - status code returned by the driver.

Please also refer to the ps2000_set_sig_gen_built_in function in the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenOff</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Set to 0V DC
    status = invoke(obj, 'setSigGenBuiltInSimple', ...
                evalin('base', 'ps2000Enuminfo.enPS2000WaveType.PS2000_DC_VOLTAGE'));
            
    % Check for error                
    if (status == 0)   

        invoke(deviceObj, 'getLastError');

    end             </MCode>
               </Code>
               <Description>setSigGenOff(obj) 'turns off' the signal generator by setting the output waveform to 0V DC.

Input parameters:

obj - the object representing the Signalgenerator group.

Output parameters:

status - status code returned by the driver.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>streaming</Name>
         <Description>The Streaming group contains a set of properties and functions related to the streaming mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Streaming1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoStop</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If DriverData.autoStop doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'autoStop') )
        
        deviceObj.DriverData.autoStop = 1;

    else

        propertyValue = deviceObj.DriverData.autoStop;
    
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.autoStop = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A value to indicate whether streaming should stop automatically when the required number of samples is reached. Should be set to 0 (FALSE) or 1 (TRUE). </Description>
            </Property>
            <Property>
               <Name>overviewBufferSize</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If DriverData.overviewBufferSize doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'overviewBufferSize') )
        
        deviceObj.DriverData.overviewBufferSize = [ ];
        
    else
        
        propertyValue = deviceObj.DriverData.overviewBufferSize;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.overviewBufferSize = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>15000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The size of the overview buffers to be used for streaming mode data capture.</Description>
            </Property>
            <Property>
               <Name>streamingIntervalMs</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If streamingIntervalMs doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'streamingIntervalMs') )
        
        deviceObj.DriverData.streamingIntervalMs = [ ];

    else

         propertyValue = deviceObj.DriverData.streamingIntervalMs;
         
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.streamingIntervalMs = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>streamingIntervalMs is the time interval (in milliseconds) between samples when capturing data in streaming mode.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>clearFastStreamingParameters</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function clearFastStreamingParameters(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    calllib('ps2000Wrap', 'clearFastStreamingParameters', ...
        deviceObj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>clearFastStreamingParameters(obj) resets parameters used for fast streaming to 0.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

None.</Description>
            </Method>
            <Method>
               <Name>getFastStreamingData</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numValues, startTime, bufferChA, bufferChB, overflow, triggerAt, trigger] = getFastStreamingData(obj, startTime)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');
    
    % Obtain channel settings array to channel x data field matrix
    channelSettings = deviceObj.DriverData.channelSettings;

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
               
        % Set device streaming
        status = invoke(obj, 'ps2000RunStreamingNs', 1);
        
        % Ensure auto stop flag is set to true
        deviceObj.DriverData.autoStop = PicoConstants.TRUE;
        
        autoStopped = 0;
        
        totalSamples = 0;
        previousValues = 0;
        
        % Poll the device
        while(autoStopped == PicoConstants.FALSE)
            
            ready = 0;
            
            while(ready == PicoConstants.FALSE)
                
                status = invoke(obj, 'pollFastStreaming');

                ready = invoke(obj, 'isFastStreamingReady');
                
            end
            
            [totalValues, overflow, triggeredAt, triggered, autoStopped, ...
                isAppBufferFull, startIndex] = invoke(obj, 'getFastStreamingDetails');
            
            previousValues = totalValues - totalSamples;
            totalSamples = totalValues;
            
            if(autoStopped)
               
                disp('Auto stop');
                
                break;
                
            end
            
        end
        
        status = invoke(deviceObj, 'ps2000Stop');
        invoke(obj, 'clearFastStreamingParameters');
        
        disp('Retrieving data...');
        
        startTime = 0.0;
        bufferChA = [];
        bufferChB = [];
        chC = [];
        chD = [];
        overflow = 0;
        triggerAt = 0;
        trigger = 0;
        
        % Pass parameters as pointers
        
        pStartTime = libpointer('doublePtr', 0.0);
        pBufferA = libpointer;
        pBufferB = libpointer;
        pOverflow = libpointer('int16Ptr', 0);
        pTriggerAt = libpointer('uint32Ptr', 0);
        pTrigger = libpointer('int16Ptr', 0);
        
        % Channel A
        if(channelSettings(1,1) == PicoConstants.TRUE)
           
            pBufferA = libpointer('int16Ptr', zeros(deviceObj.DriverData.numberOfSamples, 1));
            
        end
        
        % Channel B
        if(channelSettings(2,1) == PicoConstants.TRUE)
           
            pBufferB = libpointer('int16Ptr', zeros(deviceObj.DriverData.numberOfSamples, 1));
            
        end
        
        numValues = calllib('ps2000', 'ps2000_get_streaming_values_no_aggregation', ...
            deviceObj.DriverData.unitHandle, pStartTime, pBufferA, pBufferB, [], [], ...
            pOverflow, pTriggerAt, pTrigger, deviceObj.DriverData.numberOfSamples);
        
        if(numValues == 0)
           
            error('getFastStreamingData - ps2000_get_streaming_values_no_aggregation: parameter out of range');
            
        else
            
            startTime = pStartTime.Value;
            overflow = pOverflow.Value;
            triggerAt = pTriggerAt.Value + 1; % Offset by 1 as zero-based index
            trigger = pTrigger.Value;
            
            % Convert channel data to milliVolts 
            deviceObj.DriverData.maxADCValue;
            
            % Channel A
            if(channelSettings(1,1) == PicoConstants.TRUE)
                
                chARange = channelSettings(1,3);
                
                bufferChA = adc2mv(pBufferA.Value(1:numValues), PicoConstants.SCOPE_INPUT_RANGES(chARange + 1), ...
                    deviceObj.DriverData.maxADCValue);
                
            end
            
            if(channelSettings(2,1) == PicoConstants.TRUE)
                
                chBRange = channelSettings(2,3);
                
                bufferChB = adc2mv(pBufferB.Value(1:numValues), PicoConstants.SCOPE_INPUT_RANGES(chBRange + 1), ...
                    deviceObj.DriverData.maxADCValue);
                
            end
            
        end
        
    else
        
        error('getFastStreamingData: function not supported by this device.');
        
    end
</MCode>
               </Code>
               <Description>getFastStreamingData(obj, startTime) collects fast streaming data without aggregation returning the data collected and parameters.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

This function may be used with the Test and Measurement Tool to collect data.

Input parameters:

obj - the object representing the Streaming group.
startTime - the time in nanoseconds of the first data sample required.

Output parameters:

numValues - the number of values written to each buffer.

startTime - as above

bufferChA - an array containg data values in milliVolts for Channel A.

bufferChB - an array containg data values in milliVolts for Channel B.

overflow - represents bit fields indicating whether the voltage on each of 
                 the input channels has overflowed.

triggerAt - an index representing the sample at which the trigger occurred 
                 (if trigger is true). This is offset by 1 for indexing in MATLAB.

trigger - a boolean value indicating if a trigger has occurred and triggerAt is valid.

For further information on the ps2000_run_streaming_ns and ps2000_get_streaming_values_no_aggregation functions 
please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>getFastStreamingDetails</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [totalValues, overflow, triggeredAt, triggered, hasAutoStopped, isAppBufferFull, startIndex] = getFastStreamingDetails(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    pOverflow = libpointer('int16Ptr', 0);
    pTriggeredAt = libpointer('uint32Ptr', 0);
    pTriggered = libpointer('int16Ptr', 0);
    pHasAutoStopped = libpointer('int16Ptr', 0);
    pIsAppBufferFull = libpointer('int16Ptr', 0);
    pStartIndex = libpointer('uint32Ptr', 0);
    
    totalValues = 0;
    
    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
         
        [totalValues] = calllib('ps2000Wrap', 'GetFastStreamingDetails', ...
            deviceObj.DriverData.unitHandle, pOverflow, pTriggeredAt, ...
            pTriggered, pHasAutoStopped, pIsAppBufferFull, pStartIndex);
        
        overflow = pOverflow.Value;
        triggeredAt = pTriggeredAt.Value + 1;
        triggered = pTriggered.Value;
        hasAutoStopped = pHasAutoStopped.Value;
        isAppBufferFull = pIsAppBufferFull.Value;
        startIndex = pStartIndex.Value;
        
    else
        
        error('getFastStreamingDetails: function not supported by this device');
        
    end
    
    
    
    </MCode>
               </Code>
               <Description>getFastStreamingDetails(obj) returns the total number of samples collected at the time of call and and provides 
information when collecting data in fast streaming mode.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

totalValues -  the total number of samples collected from the driver at the time of call.

overflow - a bit field indicating whether the voltage on each of the input channels has overflowed.

triggeredAt - an index into the buffers indicating the number of the the sample at the trigger reference point. 
                      It is valid only when trigger is TRUE. This is offset by 1 from the underlying driver.

triggered - boolean value to indicate if a trigger has occurred and triggeredAt is valid.

hasAutoStopped - indicates if the device has stopped after the number of samples has been collected.

isAppBufferFull - indicates if any of the application buffers have become full (valid only if the setBuffer function has 
                          been called).

startIndex - the start index in the application buffer of the next set of data received.</Description>
            </Method>
            <Method>
               <Name>getStreamingValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [bufferChA, bufferChB, overflow, numValues] = getStreamingValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.FALSE)
        
        numberOfValues = deviceObj.DriverData.numberOfSamples;
        
        pBufferChA = [];
        pBufferChB = [];
        pOverflow = libpointer('int16Ptr', 0);

         % Setup channel A if enabled
        if(deviceObj.DriverData.channelSettings.channelA.enabled == PicoConstants.TRUE)

            pBufferChA = libpointer('int16Ptr', zeros(numberOfValues, 1));

        end

        % Set up Channel B if there are two channels and if it is enabled

        if(deviceObj.DriverData.channelCount == PicoConstants.DUAL_SCOPE &amp;&amp; ...
                deviceObj.DriverData.channelSettings.channelB.enabled == PicoConstants.TRUE)

            pBufferChB = libpointer('int16Ptr', zeros(numberOfValues, 1));

        end

        % Channel C and D do not exist so use '[]'

        numValues = calllib('ps2000', 'ps2000_get_values', deviceObj.DriverData.unitHandle, ...
            pBufferChA, pBufferChB, [], [], pOverflow, numberOfValues);

        if(numValues &gt; 0)
            
            overflow = pOverflow.Value;
            
            % Convert data to milliVolts
            if(deviceObj.DriverData.channelSettings.channelA.enabled == PicoConstants.TRUE)

                chARange = deviceObj.DriverData.channelSettings.channelA.range;

                bufferChA = adc2mv(pBufferChA.Value, PicoConstants.SCOPE_INPUT_RANGES(chARange + 1), ...
                    deviceObj.DriverData.maxADCValue);

            end

            if(deviceObj.DriverData.channelCount == PicoConstants.DUAL_SCOPE &amp;&amp; ...
                deviceObj.DriverData.channelSettings.channelB.enabled == PicoConstants.TRUE)

                chBRange = deviceObj.DriverData.channelSettings.channelB.range;

                bufferChB = adc2mv(pBufferChB.Value, PicoConstants.SCOPE_INPUT_RANGES(chBRange + 1), ...
                    deviceObj.DriverData.maxADCValue);

            end

        else

            error('getStreamingValues: one or more parameters out of range or device not in suitable mode');

        end
    
    else
        
        error('getStreamingValues: Device has Fast Streaming - use getFastStreamingData instead.');
        
    end</MCode>
               </Code>
               <Description>This function is not currently supported.</Description>
            </Method>
            <Method>
               <Name>isFastStreamingReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function ready = isFastStreamingReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
    
        ready = calllib('ps2000Wrap', 'FastStreamingReady', deviceObj.DriverData.unitHandle);

    else
        
        error('isFastStreamingReady: function not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>isFastStreamingReady(obj) is used to poll the driver to verify that data is ready to be received. 

The PollFastStreaming function must have been called prior to calling this function.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

Input parameters:

obj - the object representing the Block group.

Output parameters:

ready - 0 if data is not yet available, 1 if data is ready to be collected.</Description>
            </Method>
            <Method>
               <Name>pollFastStreaming</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = pollFastStreaming(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
    
        status = calllib('ps2000Wrap', 'PollFastStreaming', deviceObj.DriverData.unitHandle);
        
    else
       
        error('pollFastStreaming: function not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>pollFastStreaming(obj) facilitates communication with the driver to return the next block of 
values when capturing data in streaming mode.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_get_streaming_last_values return values function please refer 
to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps2000OverviewBufferStatus</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, previousBufferOverrun] = ps2000OverviewBufferStatus(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');
    
    previousBufferOverrun = 0;

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
    
        [status, previousBufferOverrun] = calllib('ps2000', 'ps2000_overview_buffer_status', ...
            deviceObj.DriverData.unitHandle, previousBufferOverrun);
        
        if(status == 1)
           
            error('ps2000OverviewBufferStatus - invalid handle');
            
        end
    
    else
        
        error('ps2000OverviewBufferStatus - function not supported by device');
        
    end</MCode>
               </Code>
               <Description>ps2000OverviewBufferStatus(obj) indicates whether or not the overview buffers used by the 
ps2000RunStreamingNs function have overrun.

The overviewBufferSize property can then be adjusted.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

status - status code returned by the driver.
previousBufferOverrun - boolean indicating if the overview buffers have overrun.

For further information on the ps2000_overview_buffer_status function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000RunStreaming</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000RunStreaming(obj, windowed)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.FALSE)
        
        if(deviceObj.DriverData.streamingIntervalMs &lt; 1)
           
            error('ps2000RunStreaming: streaming interval must not be less than 1 millisecond.');
            
        end
        
        if(deviceObj.DriverData.numberOfSamples &lt; 1 || deviceObj.DriverData.numberOfSamples &gt; 60000)
           
            error('ps2000RunStreaming: numberOfSamples must be between 1 and 60000.');
            
        end
        
        status = calllib('ps2000', 'ps2000_run_streaming', deviceObj.DriverData.unitHandle, ...
            deviceObj.DriverData.streamingIntervalMs, deviceObj.DriverData.numberOfSamples, windowed);
        
        if(status == 0)
           
            error('ps2000RunStreaming: Problem has occurred - check parameters are in range');
            
        end
        
    else
        
        error('ps2000RunStreaming: Device has Fast Streaming - use getFastStreamingData instead.');
        
    end</MCode>
               </Code>
               <Description>ps2000RunStreaming(obj, windowed) tells the oscilloscope to start collecting data in compatible streaming 
mode.

This function is for the PicoScope 2104, 2105 and 2202 ONLY and is NOT currently supported.

</Description>
            </Method>
            <Method>
               <Name>ps2000RunStreamingNs</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000RunStreamingNs(obj, noOfSamplesPerAggregate)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
        
        timeUnits = evalin('base', 'ps2000Enuminfo.enPS2000TimeUnits.PS2000_MS');

        sampleInterval = deviceObj.DriverData.streamingIntervalMs;
        
        % Convert time from milliseconds
        
        % &gt;= 1MS/s max is most likely ~30MS/s depending on PC
        if(sampleInterval &gt;= 1e-6 &amp;&amp; sampleInterval &lt; 1e-3)
            
            sampleInterval = sampleInterval * 1e6;
            timeUnits = evalin('base', 'ps2000Enuminfo.enPS2000TimeUnits.PS2000_NS');
        
        elseif(sampleInterval &gt;= 1e-3 &amp;&amp; sampleInterval &lt; 1)
                
            sampleInterval = sampleInterval * 1e3;
            timeUnits = evalin('base', 'ps2000Enuminfo.enPS2000TimeUnits.PS2000_US');
                    
        elseif(sampleInterval &gt;= 1 &amp;&amp; sampleInterval &lt; 1e3)
                
                % No change as milliseconds set
                
        elseif(sampleInterval &gt;= 1e3)
        
            sampleInterval = sampleInterval * 1e-3;
            timeUnits = evalin('base', 'ps2000Enuminfo.enPS2000TimeUnits.PS2000_S');
                
        else
            
            error('ps2000RunStreamingNs: sampling interval not in range');    
                
        end
        
        status = calllib('ps2000Wrap', 'setCollectionInfo', deviceObj.DriverData.unitHandle, ...
                    deviceObj.DriverData.numberOfSamples, deviceObj.DriverData.overviewBufferSize);
                
        if(status == 0)
            
            error('ps2000RunStreamingNs: Invalid data collection parameters passed to setCollectionInfo().');    
            
        end

        status = calllib('ps2000', 'ps2000_run_streaming_ns', deviceObj.DriverData.unitHandle, ...
            sampleInterval, timeUnits, deviceObj.DriverData.numberOfSamples, ...
            deviceObj.DriverData.autoStop, noOfSamplesPerAggregate, ...
            deviceObj.DriverData.overviewBufferSize);

        if(status == 0)

            error('ps2000RunStreamingNs - a problem has occurred or a value is out of range.')

        end
        
    else
       
        error('ps2000RunStreamingNs: function not supported by this device.')
        
    end</MCode>
               </Code>
               <Description>ps2000RunStreamingNs(obj, noOfSamplesPerAggregate) tells the oscilloscope to start collecting data in fast 
streaming mode.

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

Input parameters:

obj - the object representing the Streaming group.
noOfSamplesPerAggregate - the number of incoming samples that the driver will merge together.

NOTE: Aggregation is not currently fully supported, please set the above parameter to 1.

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_run_streaming_ns function please refer to the 
PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setBuffer</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setBuffer(obj, channel, pBuffer, bufferSize)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object
    deviceObj = get(obj, 'Parent');

    if(deviceObj.DriverData.hasFastStreaming == PicoConstants.TRUE)
        
        if(channel &lt; 0 || channel &gt; PicoConstants.DUAL_SCOPE - 1)
        
            error('setBuffer: Channel out of range.');
        
        else
         
            calllib('ps2000Wrap', 'SetBuffer', deviceObj.DriverData.unitHandle, ...
                channel, pBuffer, bufferSize);
        
        end
        
    else
       
        error('setBuffer: Fast Streaming not supported by this device.')
        
    end</MCode>
               </Code>
               <Description>setBuffer(obj, channel, pBuffer, bufferSize) sets the application buffer in order to copy data from the 
driver overview buffers in Fast Streaming mode.

NOTE: Fast streaming data collection will stop when the application buffer becomes full (see getFastStreamingDetails).

Applies to PicoScope 2203, 2204, 2204A, 2205, and 2205A models ONLY.

Input parameters:

obj - the object representing the Streaming group.

channel - the channel number (should be a PS2000_CHANNEL enumeration value).

pBuffer - a libpointer representing the application buffer.

bufferSize - the length of the buffer defined as the TOTAL number of samples to be collected.
		This can be greater than the numberOfSamples property.

Output parameters:

None.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>trigger</Name>
         <Description>The Trigger group contains a set of properties and functions related to the trigger functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Trigger1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoTriggerMs</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If autoTriggerMs doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'autoTriggerMs') )
        
        deviceObj.DriverData.autoTriggerMs = 0;
        
    else
        
        propertyValue = deviceObj.DriverData.autoTriggerMs;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    deviceObj.DriverData.autoTriggerMs = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of milliseconds the device will wait if no trigger occurs.

Set to 0 to wait indefinitely for a trigger.</Description>
            </Property>
            <Property>
               <Name>delay</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % If delay doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'delay') )
        
        deviceObj.DriverData.delay = 0;
        
    else
        
        propertyValue = deviceObj.DriverData.delay;
        
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    deviceObj.DriverData.delay = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="100.0" Min="-100.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The delay, as a percentage of the requested number of data points, between the trigger event and the start of the block. 

It should be in the range -100% to +100%. 

Example values:

0% -  The trigger event is at the first data value in the block.
- 50% - The trigger event is in the middle of the block</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>setSimpleTrigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSimpleTrigger(obj, source, thresholdMv, direction)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Obtain the parent object and it's unitHandle property
    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    % Default value - 5000 mV
    channelRange =  evalin('base', 'ps2000Enuminfo.enPS2000Range.PS2000_5V');

    channelSettings = deviceObj.DriverData.channelSettings;

    switch(source)

        % Channel A
        case evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_A')

            channelRange = channelSettings(1,3);

        % Channel B
        case evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_CHANNEL_B')

            channelRange = channelSettings(2,3);

        % If trigger is being switched off
        case evalin('base', 'ps2000Enuminfo.enPS2000Channel.PS2000_NONE');

            % Leave as default value

        otherwise

            error('setSimpleTrigger: Invalid channel specified');

    end

    % Obtain the range being used in milliVolts
    channelRangeMv = PicoConstants.SCOPE_INPUT_RANGES(channelRange + 1);

    % Calculate the threshold in ADC counts
    thresholdAdc = mv2adc(thresholdMv, channelRangeMv, deviceObj.DriverData.maxADCValue);
    
    % Check if delay is integer
    if(isinteger(deviceObj.DriverData.delay))

        status = calllib('ps2000', 'ps2000_set_trigger', unitHandle, ...
                    source, thresholdAdc, direction, deviceObj.DriverData.delay, ...
                    deviceObj.DriverData.autoTriggerMs);

    else

        status = calllib('ps2000', 'ps2000_set_trigger2', unitHandle, ...
                    source, thresholdAdc, direction, deviceObj.DriverData.delay, ...
                    deviceObj.DriverData.autoTriggerMs);

    end

    if(status == 0)

        error('setSimpleTrigger: One or more parameters are out of range.');

    end

    clear thresholdAdc;
    clear channelRangeMv;</MCode>
               </Code>
               <Description>setSimpleTrigger(obj, source, thresholdMv, direction, delay, autoTriggerMs) used to enable or disable basic triggering and its parameters.

This function may be used with the Test and Measurement Tool when block data capture is undertaken.

Input parameters:

obj - the object representing the Trigger group.

source - set to 0 (Channel A), 1 (Channel B) or 5 (None).

thresholdMv -  the trigger threshold in milliVolts.

direction - use 0 (Rising) or 1 (Falling)

delay - the delay, as a percentage of the requested number of data points, 
	between the trigger event and the start of the block. This  maybe specified as an integer 
	(use int16(delay) for the input value), or a floating point value.

autoTriggerMs - the delay in milliseconds after which the oscilloscope will collect samples if no trigger event occurs

Output parameters:

status - status code returned by the driver.

For further information on the ps2000_set_trigger and ps2000_set_trigger2 functions 
please refer to the PicoScope 2000 Series PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setTriggerOff</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerOff(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    % Obtain the parent object and it's unitHandle property
    deviceObj = get(obj, 'Parent');

    status = calllib('ps2000', 'ps2000SetAdvTriggerChannelProperties', ...
        deviceObj.DriverData.unitHandle, [], 0, 0);
    
    if(status == 0)
       
        % TBD
        
    end</MCode>
               </Code>
               <Description>setTriggerOff(obj) disables the trigger on the device.

This function may be used with Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.

Output parameters:

status - status code returned by the driver.

</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>